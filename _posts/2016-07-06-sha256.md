---
layout: page
title: "Case Study #2: SHA-256"
category: doc
date: 2016-07-06 09:26:00
order: 6
---

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

### I. Introduction

The SHA-2 (Secure Hash Algorithm) is a set of cryptographic hash functions designed by the National Security Agency and SHA-256 is one of these algorithms. These algorithms were defined semi-formally in documents produced by [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf).
Cryptographic algorithms are good candidates for hardware implementation because they typically possess components whose performance benefits from hardware acceleration. 
But they are also prime candidates for formal verification because of their critical role in maintaining security and integrity in a wide variety of systems. 

This case study explores the model-driven design and synthesis of a hardware accelerator for the SHA-256 cryptographic hash function.
The approach is semantics-driven, starting from a reference semantics for SHA-256.
The whole derivation takes place within the Haskell functional language and so the hardware accelerator produced by the ReWire compiler is formally verifiable with respect to the reference semantics using equational reasoning in Haskell.

##### __Overview__

The development in this case study proceeds along the same lines as in [Case Study #1]({{ site.baseurl }}{% post_url 2016-07-04-crossbarswitch %}). That is, first we develop a reference semantics for SHA-256 in Haskell, show how to transform it into a ReWire implementation, and, finally, show how the resulting implementation is synthesized. The code that we make use of in this is as follows:

* [ReWirePrelude.hs]({{ site.baseurl }}/assets/code/sha256/ReWirePrelude.hs): some standard definitions.
* [Reference256.hs]({{ site.baseurl }}/assets/code/sha256/Reference256.hs): the reference semantics for SHA-256 in Haskell.
* [TestHarness.hs]({{ site.baseurl }}/assets/code/sha256/TestHarness.hs): harness for testing specifications.
* [FirstImplementation.hs]({{ site.baseurl }}/assets/code/sha256/FirstImplementation.hs) and [SecondImplementation.hs]({{ site.baseurl }}/assets/code/sha256/SecondImplementation.hs): two derived implementations of SHA256 in Haskell.
* [RWFirstImplementation.hs]({{ site.baseurl }}/assets/code/sha256/RWFirstImplementation.hs) and [RWSecondImplementation.hs]({{ site.baseurl }}/assets/code/sha256/RWSecondImplementation.hs): two derived implementations of SHA256 in ReWire.
* [RWFirstImplementation.vhd]({{ site.baseurl }}/assets/code/sha256/RWFirstImplementation.vhd) and [RWSecondImplementation.vhd]({{ site.baseurl }}/assets/code/sha256/RWSecondImplementation.vhd): two VHDL implementations of SHA256 generated by the ReWire compiler.
* [Counter.hs]({{ site.baseurl }}/assets/code/sha256/Counter.hs), [Globals256.hs]({{ site.baseurl }}/assets/code/sha256/Globals256.hs), [MetaprogrammingRW.hs]({{ site.baseurl }}/assets/code/sha256/MetaprogrammingRW.hs), and [prims.vhd]({{ site.baseurl }}/assets/code/sha256/prims.vhd): various and sundry files whose purpose will be explained along the way.
* [Tarball of All This Code]({{ site.baseurl }}/assets/code/sha256/sha256-casestudy.tar.gz).

### II. Haskell Reference Semantics for SHA-256

#### __The Top Level__

The input to the SHA-256 algorithm is assumed to be a sequence of bytes and its output is a _digest_ of
eight 32-bit words. Respectively, these are represented in Haskell as the types `[Char]` (i.e., a list of ASCII characters) and `Oct Word32`.
A Haskell function implementing this algorithm, 
`refsha256`, is presented below; its type is `[Char] -> Oct Word32`.
The function `refsha256` is the composition of functions `pad`, `sha256`, and `runM` which are discussed in more detail below.

```` haskell
refsha256 :: [Char] -> Oct Word32
refsha256 = runM . sha256 . pad

pad    :: [Char] -> [Hex Word32]
sha256 :: [Hex Word32] -> M (Oct Word32)
runM   :: M a -> a

data Oct a = Oct a a a a a a a a
data Hex a = Hex a a a a a a a a a a a a a a a a
````

The SHA-256 algorithm first pads the input sequence so that the result has length as a multiple of 512 bits.
The padded input is then parsed into 512 bit blocks, 
$M^{(1)},\ldots,M^{(N)}$. Each of these blocks, $M^{(i)}$, is further parsed into sixteen 32-bit words, 
$M_0^{(i)},\ldots,M_{15}^{(i)}$ and represented in Haskell with the type `Hex Word32`--- thus, the type of the `pad` function. The code for `pad` (as well as for `runM`) is found in `TestHarness.hs`; their definitions would not be illuminating here.

The function `sha256` implements the main loop of the SHA-256 algorithm. It takes the sequence of blocks formatted by `pad` (i.e., a list of type `Hex Word32`) as input and produces a computation of a digest (i.e., a computation of type `M (Oct Word32)`) as output. Here, `M` is a _monad_, which is a construction used for representing side-effects in the pure functional language Haskell. We define `M` and its use below.

#### __Testing Against the NIST Standard__

The NIST document defining SHA-256 provides three example hash computations against which one may test implementations of the algorithm. The transcript below summarizes the tests applied to `refsha256`. The tests apply `refsha256` to messages `msg1`, `msg2`, and `msg3`; `msg1` is just `"abc"` while the other two are too long to print easily here.

```` haskell
ghci> refsha256 msg1
  Oct 3128432319 2399260650 1094795486 1571693091 
      2953011619 2518121116 3021012833 4060091821
ghci> hashed1
  Oct 3128432319 2399260650 1094795486 1571693091 
      2953011619 2518121116 3021012833 4060091821
ghci> refsha256 msg2
  Oct 613247585 3523623096 3854575251 205414457 
      2738676825 1694441831 4142722516 433784513
ghci> hashed2
  Oct 613247585 3523623096 3854575251 205414457 
      2738676825 1694441831 4142722516 433784513
ghci> refsha256 msg3
  Oct 3452399196 2568289170 2174863330 2228698727 
      4051737160 2761367566 74267084 3339791568
ghci> hashed3
  Oct 3452399196 2568289170 2174863330 2228698727 
      4051737160 2761367566 74267084 3339791568 
````

In the above transcript, a test harness is loaded into the GHC (Glasgow Haskell Compiler) interpreter. First the `refsha256` is applied, producing the hash digest calculated by the reference semantics. Then, the published hash digests from [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf), Appendix B, are displayed---these are `hashed1`, `hashed2`, and `hashed3`, respectively---and note that they are identical to the corresponding output of `refsha256`. By default, these digests are displayed in decimal format rather than the hexadecimal format in which they appear in [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf).


#### __SHA-256 Logical Operators__

SHA-256 defines a number of operations on 32-bit words called _logical operators_ in Sections 3.2 and 4.1.2 of [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf). These are excerpted in part below:

<img src="{{ site.baseurl }}/images/sha256-functions.png" style="display: block; margin: 0 auto; max-width: 75%;" alt="Screenshot" />

Each of these functions transliterates simply into Haskell using built-in functions and data from the Haskell libraries, `Data.Bit` and `Data.Word`.
Within the code listing below, `.&.`, `complement`, and `xor` are, resp., the bitwise _and_, complement and exclusive _or_ operations. The `rotateR` and `shiftR` functions are the rotate right and shift right operations.

```` haskell
ch :: Word32 -> Word32 -> Word32 -> Word32
ch x y z = (x .&. y) `xor` (complement x .&. z)

maj :: Word32 -> Word32 -> Word32 -> Word32
maj x y z = (x .&. y) `xor` (x .&. z) `xor` (y .&. z)

bigsigma0 :: Word32 -> Word32
bigsigma0 x = (rotateR x 2) `xor` (rotateR x 13) `xor` (rotateR x 22)

bigsigma1 :: Word32 -> Word32
bigsigma1 x = (rotateR x 6) `xor` (rotateR x 11) `xor` (rotateR x 25)

sigma0 :: Word32 -> Word32
sigma0 x = (rotateR x 7) `xor` (rotateR x 18) `xor` (shiftR x 3)

sigma1 :: Word32 -> Word32
sigma1 x = (rotateR x 17) `xor` (rotateR x 19) `xor` (shiftR x 10)
````

#### __Constants and Counters__

The inner loop of the SHA-256 algorithm is, in effect, a for-loop counting from $0$ to $63$. To allow expression of this in Haskell, we define a counter type `Ctr` below.
It would be possible in the reference semantics to use the built-in `Int` type as a loop variable, but, anticipating the shift to hardware implementation, a discrete, finite type like `Ctr` makes more sense.
The SHA-256 algorithm also makes use of 64 constants (these are defined in Section 4.2.2 of [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf)). We index these constants via the `seed` function. This code appears in `Counter.hs`.

```` haskell
data Ctr = C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  |
           C8  | C9  | C10 | C11 | C12 | C13 | C14 | C15 |
           C16 | C17 | C18 | C19 | C20 | C21 | C22 | C23 |
           C24 | C25 | C26 | C27 | C28 | C29 | C30 | C31 |
           C32 | C33 | C34 | C35 | C36 | C37 | C38 | C39 |
           C40 | C41 | C42 | C43 | C44 | C45 | C46 | C47 |
           C48 | C49 | C50 | C51 | C52 | C53 | C54 | C55 |
           C56 | C57 | C58 | C59 | C60 | C61 | C62 | C63 

incCtr :: Ctr -> Ctr
incCtr C0  = C1
    ...stuff deleted...
incCtr C62 = C63
incCtr C63 = C0 

seed :: Ctr -> Word32
seed C0  = 0x428a2f98
    ...stuff deleted...
seed C63 = 0xc67178f2
````

#### Memory Layout of SHA-256

SHA-256 is an imperative algorithm, meaning that it involves assignments to registers, loops, etc. 
To program in imperative style in Haskell, one normally uses state monads. This section will provide a quick refresher of the fundamentals of monadic programming in Haskell for the sake of being as self-contained as possible. For readers requiring more information, please consult, for example,  [Liang 1995](http://dl.acm.org/citation.cfm?id=199528).

There are four types of storage in the algorithm:

- Intermediate Digest: temporary storage for a digest value; of type `Oct Word32`.
- Current Block: the current, formatted block; of type `Hex Word32`.
- Digest: the value of the digest; of type `Oct Word32`.
- Loop Counter: the current value of the loop counter register of type `Ctr`.

To create storable registers for each of these types, we create a monad `M` using the state monad transformer `StateT` in the code below. Notice that, for each type of register above, there is a corresponding application of the state monad transformer. This stack of `StateT` applications applies to the `Identity` monad, which has no registers at all.

```` haskell
type M = 
  StateT (Oct Word32)                -- Intermediate Digest
    (StateT (Hex Word32)             -- Current Block
       (StateT (Oct Word32)          -- Digest
          (StateT Ctr Identity)))    -- Loop Counter
````

For each register type, there are corresponding read and write operations in `M` for manipulating the register. These operations are prepended with `get` and `put`, respectively, and are defined below.
Paying attention to the types of the operation is the best way to understand them. For example,
to read the current digest value, one uses `getDigest :: M (Oct Word32)`.
This type signifies that `getDigest` is an `M` computation that returns an `Oct Word32` value.
To update the current value of the digest register, one uses `putDigest :: Oct Word32 -> M()`.
For a given 
`d :: Oct Word32`, `(putDigest d) :: M()` is a computation that sets the current value of the digest register to `d`. 

```` haskell
getIntDig :: M (Oct Word32)         -- Intermediate Digest Operations
getIntDig = get
putIntDig :: Oct Word32 -> M ()
putIntDig = put

getBlock :: M (Hex Word32)          -- Current Block Operations
getBlock = lift get
putBlock :: Hex Word32 -> M ()
putBlock = lift . put

getDigest :: M (Oct Word32)         -- Digest Operations
getDigest = lift (lift get)
putDigest :: Oct Word32 -> M ()
putDigest = lift . lift . put

getCtr :: M Ctr                     -- Loop Counter Operations
getCtr = lift (lift (lift get))
putCtr :: Ctr -> M ()
putCtr = lift . lift . lift . put
````

To chain together these operations, we use Haskell's `do` notation. In the code below, first the current digest is read with `getDigest`, then the current intermediate digest is read with `getIntDig`, and finally they are added together component-wise and stored back in the digest register using `putDigest`. This `intermediate` operation is part of the Haskell reference semantics for SHA-256.

```` haskell
intermediate :: M ()
intermediate = 
   do
      Oct h1 h2 h3 h4 h5 h6 h7 h8 <- getDigest
      Oct a b c d e f g h         <- getIntDig
      putDigest (Oct (a+h1) (b+h2) (c+h3) (d+h4) 
                     (e+h5) (f+h6) (g+h7) (h+h8))
````

There is one more `M` operation to describe: `return :: a -> M a`. This polymorphic operation takes a value `v` of some type `a` and produces an `M` computation that simply returns `v`. The `return` operation produces no side effects and is, in some sense, a \"do nothing\" operation.

#### __Main Function__

Below is displayed the Haskell code for the main loop of the SHA-256 algorithm, which is represented by the recursive list function `sha256`.
The `sha256` function first initializes the digest and then passes the parsed input on to the `mainloop` function. The `mainloop` function is a straightforward rendering of the pseudo-code defining the main
loop of SHA-256 (see Section 6.2.2 of [NIST](http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf)).
The code for the message scheduling and compression routines can be found in `Reference256.hs`.

```` haskell
sha256 :: [Hex Word32] -> M (Oct Word32)
sha256 hws = do
                putDigest initialSHA256State
                mainloop hws
                getDigest

mainloop :: [Hex Word32] -> M ()
mainloop []             = return ()
mainloop (hw32 : hw32s) = do
                             hi_1 <- getDigest
                             putIntDig hi_1
                             putBlock hw32
                             putCtr C0
                             innerloop
                             mainloop hw32s

innerloop :: M ()
innerloop = do
               ctr <- getCtr
               s <- sched
               compress (seed ctr) s
               putCtr (incCtr ctr)
               case ctr of
                    C63 -> intermediate
                    _   -> innerloop

-- SHA-256 message scheduling and compression routines
sched    :: M Word32
compress :: Word32 -> Word32 -> M ()
````

### III. The First Implementation

The reference semantics as a whole will not translate directly to hardware: it makes extensive use of list types in Haskell (i.e., list types) that are of potentially unbounded size. Hardware circuits, which require a finite storage footprint, cannot accommodate such types generally. However, large parts of the reference semantics may be re-used in a ReWire specification of a circuit that computes the `sha256` function from the end of the previous section, albeit with a different calling convention to eliminate lists.

#### __Hardware Accelerator for SHA-256 in Haskell__

The code below presents the input and output signals for the hardware accelerator device; these are the `Inp` and `Out` types, resp. 
The `Init` input signal tells the accelerator to initialize the current block and begin a new hash computation. The `Load` signal instructs the accelerator to load new input into the current block register. The `DigestQ` signal is used to return the computed hash digest.
The `DigestR` output signal returns the computed hash digest and the `Nix` output signal is the default output of the accelerator.
The code below also presents the definition of the SHA-256 accelerator. 
The most important thing to note is that `devsha256` reuses most of the code directly from the reference semantics `sha256`.
First, `devsha256` outputs the `Nix` signal, receives an input `i` and passes it to `dev`. The function `dev` handles each `Inp` signal as described in the previous paragraph. 

```` haskell
data Inp = Init (Hex Word32) | Load (Hex Word32) | DigestQ
data Out = DigestR (Oct Word32) | Nix

type Device = ReacT Inp Out M ()

devsha256 :: Device
devsha256 = do 
               i <- signal Nix
               dev i

dev :: Inp -> Device
dev (Init hw32) = do
                     lift (do
                              putDigest initialSHA256State
                              hi_1 <- getDigest
                              putIntDig hi_1
                              putBlock hw32
                              putCtr C0)
                     signal Nix
                     innerloop 
dev (Load hw32) = do
                     lift (do
                              hi_1 <- getDigest
                              putIntDig hi_1
                              putBlock hw32
                              putCtr C0)
                     signal Nix
                     innerloop
dev DigestQ     = do
                     h_n <- lift getDigest 
                     i <- signal (DigestR h_n)
                     dev i

innerloop :: Device
innerloop   = do
                 ctr <- lift (do
                                 c <- getCtr
                                 s <- sched
                                 compress (seed c) s
                                 putCtr (incCtr c)
                                 return c)
                 i <- signal Nix
                 case ctr of
                      C63 -> do lift intermediate 
                                dev i
                      _   -> innerloop
````

#### __Top Level for `devsha256`__

The code below presents the top-level functions for testing the `devsha256` accelerator in Haskell. Below, we discuss the calling convention for `devsha256`, which is encapsulated as the `format` function. The `simdev` function takes a `Device` and a list of `Inp`s and computes the final `Out` signal produced by the device on those inputs. The code for both of the functions is found in `TestHarness.hs`.
Importantly, the hardware accelerator may be tested in Haskell: using `godev256` produces the same results as the `refsha256` did in Section II.

```` haskell
godev256 :: [Char] -> Out
godev256 = runM . simdev devsha256 . format . pad
format    :: [Hex Word32] -> [Inp]
simdev    :: Device -> [Inp] -> M Out
````


To call the main function from the reference semantics, one simply applies the function `sha256` to the list of input blocks. 
That is, ${\mathtt{sha256~ [{\mathit{M}}^{(\mathit{1})},\ldots,{\mathit{M}}^{(\mathit{N})}]}}$ computes a digest. 
The device version, `devsha256`, requires that this input be formatted differently, and this is accomplished with the function, `format :: [Hex Word32] -> [Inp]`. 
The code for `format` is defined in `TestHarness.hs`, but the 
action of the `format` function is described below:

$$
\mathtt{format} [M^{(1)},\ldots,M^{(N)}] =
\begin{array}[t]{l}
[\mathtt{Init}~ M^{(1)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~\mathtt{Load}~ M^{(2)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~~~~~~~~~~~~~~~~~~~~~~~~\vdots
\\
~\mathtt{Load}~ M^{(N)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~\mathtt{DigestQ}]
\end{array}
$$

This calling convention is analogous to those found in publications presenting SHA-256 accelerators hand-coded in VHDL (e.g., 
[Chaves06](http://link.springer.com/chapter/10.1007%2F11894063_24),
[Algredo13](http://www.sciencedirect.com/science/article/pii/S0141933112000993), 
[Ting02](http://link.springer.com/chapter/10.1007%2F3-540-46117-5_60), 
[McEvoy06](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1602458&tag=1), 
[Garcia14](http://www.sciencedirect.com/science/article/pii/S0045790613002966), 
[Sklavos05](http://link.springer.com/article/10.1007%2Fs11227-005-0086-5), and
[Kahri15](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7348105)).
Note that the sixty four `DigestQ` signals are used only as padding to wait for the inner loop within the device to finish. The final `DigestQ` will result in the completed hash value being returned.
