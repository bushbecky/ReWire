- Definition: a type is "simple" if it is free of arrows, recursive or
  higher-order data types, and monads.

- Assumption: we are post-lambda lifting and we have a pile of functions with
  types that are of one of the following forms (type variables are allowed but
  they must range only over simple types):

    (pure)          T1 -> T2 -> ... -> Tn -> T
                    where each Ti and T are simple.

    (state-monadic) T1 -> T2 -> ... -> Tn -> StT S1 (StT S2 (... (StT Sm I))) T
                    where each Ti, each Si, and T are simple.

    (res-monadic)   T1 -> T2 -> ... -> Tn ->
                      ReT I O (StT S1 (StT S2 (... (StT Sm I)))) T
                    where each Ti, I O, each Si, and T are simple.

  All calls to res-monadic functions must be tail calls.
  Only res-monadic functions may be recursive.
  Recursion must be loop-guarded. Loop-guarded here means that every loop
    through the call graph has at least one guarded edge. I haven't yet
    explained guarded edges.

  signal must never occur embedded in the left-hand side of a bind, *except*
    in the form of signal e >>= f e1 e2 ... ek where f is a top-level name.

- To purify a pure function: do nothing.

- To purify a state-monadic function f:

    Suppose f :: T1 -> T2 -> ... -> Tn -> StT S1 (StT S2 (... (StT Sm I))) T
    and the definition of f is f x1 ... xn = e.

    We will define a new function

    f_pure :: T1 -> ... -> Tn -> S1 -> ... -> Sm -> (T,(S1,(...,Sm)))

    Definition of f_pure is

    f_pure x1 ... xn s1 ... sm = [|purify_state_body 1 e|]

    where s1 ... sm are fresh variables and

    purify_state_body i (return e)    = "(e,(s1,(...,sm)))"
    purify_state_body i (e >>= g)     = "let
                                            (v,(s1,(...,sm))) = [|purify_state_body i e|]
                                         in
                                            g_pure v s1 ... sm"
    purify_state_body i (lift e)      = purify_state_body (i+1) e
    purify_state_body i get           = "(si,(s1,(...,sm)))"
    purify_state_body i (put e)       = "((),(s1,(...,(si-1,(e,(si+1,(...,sm)))))))"
    purify_state_body i (f e1 ... ek) = "f_pure e1 .... ek"
    purify_state_body i (case e of
                           P1 -> e1
                           ...
                           Pk -> ek)  = "case e of
                                           P1 -> [|purify_state_body i e1|]
                                           ...
                                           Pk -> [|purify_state_body i ek|]"

- To purify a resumption-monadic function f:

    Suppose f :: T1 -> T2 -> ... -> Tn ->
               ReT I O (StT S1 (StT S2 (... (StT Sm I)))) T
    and the definition of f is f x1 ... xn = e.

    We will define a new function

       f_pure :: T1 -> T2 -> ... -> Tn -> I -> S1 -> ... -> Sm -> (Either T (O,R),(S1,(...,Sm)))

    Definition of f_pure is

       f_pure x1 ... xn s1 ... sm = [|purify_res_body e|]

    where s1 ... sm are fresh variables and

    purify_res_body (return e)         = "(Left e,(s1,(...,sm)))"
    purify_res_body (signal e
                      >>= g e1 ... ek) = "(Right (e,R_g e1 ... ek),(s1,(...,sm)))"            * and create resumption point constructor for g if it doesn't already exist
    purify_res_body (signal e)         = "(Right (e,R_ret),(s1,(...,sm)))"                    * and create resumption point constructor "R_ret" if doesn't already exist
    purify_res_body (e >>= g)          = "let
                                             (Left v,(s1,(...,sm))) = [|purify_res_body e|]   * because of the restriction on signal and the excision of non-tail calls, the irrefutable pattern will be okay
                                          in
                                             g_pure v s1 ... sm"
    purify_res_body (lift e)           = "let
                                             (v,(s1,(...,sm))) = purify_state_body 1 e
                                          in
                                             (Left v,(s1,(...,sm)))"
    purify_res_body (f e1 ... ek)      = "f_pure e1 .... ek"
    purify_res_body (case e of
                       P1 -> e1
                       ...
                       Pk -> ek)       = "case e of
                                            P1 -> [|purify_res_body i e1|]
                                            ...
                                            Pk -> [|purify_res_body i ek|]"

    Create resumption point constructor for a function

      f :: T1 -> T2 -> ... -> Tn -> ReT I O (StT S1 (StT S2 (... (StT Sm I)))) T

    means to add

      R_f :: T1 -> T2 -> ... -> Tn -> R.

Pure form is:

  Special junk as follows:

    data R = ...whatever we generated during purification...

    ^^ f_pure must exist for each of the above R_f ^^

    start_pure :: S1 -> ... -> Sm -> (Either T (O,R),(S1,(...,Sm)))
    start_pure = <whatever came from purifying start>                -- compiled normally

    init_s1 :: S1
    init_s1 = <some pure expression>                                 -- compiled normally
    ...
    init_sm :: Sm
    init_sm = <some pure expression>                                 -- compiled normally

    init :: ReT I O (StT S1 (StT S2 (... (StT Sm I)))) T             -- compiled specially
    init = do let (res,(s1',(...,sm'))) = start_pure init_s1 ... init_sm
              put s1'
              lift (put s2')
              ...
              put^{m-1} sm'
              case res of
                Left x      -> return x
                Right (o,r) -> do i <- signal o
                                  loop r i

    loop :: R -> I -> ReT I O (StT S1 (StT S2 (... (StT Sm I)))) T   -- compiled specially
    loop r i = case r of
                 R_ret         = return i   -- if it exists
                 -- One of these for each resumption point:
                 R_f x y ... z = do
                                   s1 <- get
                                   s2 <- lift get
                                   s3 <- lift (lift get)
                                   ...
                                   sm <- lift^{m-1} get
                                   let (res,(s1',(...,sm'))) = f_pure x y ... z i s1 ... sm
                                   put s1'
                                   lift (put s2')
                                   ...
                                   put^{m-1} sm'
                                   case res of
                                     Left x       -> return x
                                     Right (o,r') -> do i' <- signal o
                                                        loop r' i'
